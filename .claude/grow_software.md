다음은 '지속 성장 가능한 소프트웨어' 블로그 글의 기술적 핵심 내용을 요약한 것입니다.

## 1. 비즈니스 로직 (Business Logic)
핵심 원칙은 **"상세 구현을 몰라도 비즈니스 흐름을 이해할 수 있는 코드"**를 작성하는 것입니다.

* **지양할 방식**: `Service` 클래스가 데이터 조회, 검증, 생성 등 모든 상세 구현 로직을 직접 처리하는 구조. 이는 비즈니스 흐름 파악을 어렵게 합니다.
* **추구할 방식**: `Service` 클래스는 비즈니스의 흐름을 보여주는 **중계자(Coordinator)** 역할을 합니다. 실제 작업은 명확한 단일 책임을 가진 **협력 도구 클래스(Collaborator Classes)**에 위임합니다. 이를 통해 코드만으로 비즈니스 과정을 쉽게 유추할 수 있습니다.

---

## 2. 소프트웨어 레이어 (Software Layers)
코드의 통제와 관리를 위해 명확한 레이어 구조를 정의하고 규칙을 적용합니다.

### 기본 레이어 구조
1.  **Presentation Layer**: 외부 변화에 민감한, 외부 의존성이 높은 영역입니다.
외부 영역에 대한 처리를 담당하는 코드나 요청, 응답 클래스들도 이 레이어에 속합니다.
2.  **Business Layer**: 비즈니스 로직을 표현하고 흐름을 중계하는 영역,비즈니스 로직을 투영하는 레이어입니다.
만약 코드가 계속 성장하여 비즈니스 로직이 너무 많아지거나 결합이 되어야 하는 경우 당연히 상위 레이어를 더 쌓아올립니다.
3.  **Implement Layer**: 비즈니스 로직을 이루기 위해 도구로서 상세 구현 로직을 갖고 있는 클래스들이 있습니다.
이곳은 가장 많은 클래스들이 존재하고 있으면서 구현 로직을 담당하기 때문에 재사용성도 높은 핵심 레이어입니다.
도구레이어는 책임이 명확한 네이밍은 reader,finder,writer,appender,generater 등 책임이 명확함, 책임이 모호할때는,
임시방편으로 process, manager 를 쓰고 책임을 명확히 함
4.  **Data Access Layer**: 상세 구현 로직이 다양한 자원에 접근할 수 있는 기능을 제공하는 레이어입니다.
특징으로는 기술 의존성을 격리하여 구현 로직에게 순수한 인터페이스를 제공합니다.

### 레이어 제약 규칙
1.  **단방향 참조**: 레이어는 위에서 아래로만 (Presentation → Business → Implement → Data Access) 참조해야 합니다.
2.  **역류 금지**: 하위 레이어가 상위 레이어를 참조할 수 없습니다. (예: `Implement Layer`가 `Business Layer`를 참조하는 것을 금지)
3.  **건너뛰기 금지**: 상위 레이어가 중간 레이어를 건너뛰고 하위 레이어를 직접 참조할 수 없습니다. (예: `Business Layer`가 `Data Access Layer`를 직접 참조하는 것을 금지)
4.  **동일 레이어 참조 금지**: 같은 레이어의 클래스끼리는 서로 참조하지 않는 것을 원칙으로 합니다.
    * **예외**: `Implement Layer` 내에서는 도구 클래스 간의 재사용과 조합을 위해 상호 참조를 허용합니다.
5. Implement Layer가 Data Access Layer를 이용하여 상세 구현 로직을 풀어내고, Business Layer는 Implement Layer를 사용하여 비즈니스 로직을 풀어가는 형태가 됩니다,비즈니스를 담당하는 영역이 구현 기술이나 구현 로직을 모르고 있는 형태로 유지하고 레이어의 오염을 막기 위한 규칙입니다

---

## 3. 모듈화 (Modularization)
기술 의존성을 격리하고 모듈 간 결합도를 낮추어 변경에 유연한 구조를 만듭니다.

### 핵심 원칙: `implementation` 키워드 사용
* Gradle 의존성 설정 시, `api` 대신 **`implementation`** 키워드를 사용합니다.
* **`implementation`**: 해당 모듈이 의존하는 라이브러리가 상위 모듈로 전파되는 것을 막습니다. 예를 들어 `db-module`이 JPA를 `implementation`으로 의존하면, `db-module`을 사용하는 `api-module`은 JPA의 존재를 알 수 없으며 관련 클래스에 접근할 수 없습니다.
* **`api`**: 의존성을 상위 모듈로 전파시켜, 상위 모듈이 하위 기술에 직접 의존하게 될 위험이 있습니다. 이는 레이어 오염과 강한 결합을 유발할 수 있습니다.

### 모듈화의 목표와 이점
* **기술 격리**: `api-module`은 데이터베이스 접근 기술이 JPA인지 다른 것인지 알 필요가 없습니다. 오직 `db-module`이 제공하는 인터페이스에만 의존합니다.
* **교체 용이성**: 데이터베이스 기술을 JPA에서 다른 것으로 변경해야 할 때, `db-module`의 내부 구현만 수정하면 됩니다. `api-module`을 포함한 다른 모듈은 코드 수정 없이 그대로 유지될 수 있습니다.
* **책임 분리**: 외부 API 연동, 데이터베이스 접근, 배치 작업 등 각 기능이 명확한 책임을 가진 별도의 모듈로 분리됩니다.

### 모듈!=레이어
- 모듈과 레이어는 1:1 대칭이 아님, core-api 모듈에는 presentation layer,core-domain 모듈에는 business layer, implement layer(도구 레이어)(implement layer(도구레이어) 를 하위에 레이어를 추가했을경우) 가 있고,
Storage 모듈에 data access layer 가 존재 client 모듈은 외부 연동 레이어의 바깥영역

### 모듈!=개념,격벽 & 레이어!=개념,격벽
- 개념과 격벽의 문서를 같이 첨부하는데 절대 대칭으로 구분 금지
- 개념과 격벽에 상세내용은 개념_격벽 md 문서 참고
---

## 4. 최종 목표: 통제 (Control) 와 제어 (Governance)
- 위에서 설명한 비즈니스 로직, 레이어, 모듈화 원칙들은 모두 소프트웨어를 완벽하게 **통제**하고 예측 가능하게 **제어**하기 위한 수단입니다. 이를 통해 변화에 유연하게 대응하고, 오랜 시간 동안 지속적으로 성장할 수 있는 소프트웨어를 만드는 것을 목표로 합니다.

## ex structure
```
├── build.gradle
├── clients // 외부 api
│   ├── build.gradle
│   └── exchange-rate
├── core
│   ├── core-api
│   ├── core-domain
│   ├── core-enum
│   └── test
├── docker-compose.front-local.yml
├── docker-compose.yml
├── gradle
│   └── wrapper
├── gradle.properties
├── gradlew
├── gradlew.bat
├── lint.gradle
├── settings.gradle
├── storage
│   └── db-core
├── support
│   ├── logging
│   └── monitoring
└── web
    └── security

```